# 스프링 배치 실습(1)

## 스프링 배치 실습 환경
이제 스프링 배치를 위해 실습을 시작해보자. 실습을 위한 환경은 다음과 같다.

- java8

- spring boot 2.x

- gradle

- lombok, jpa, mysql, h2, jdbc, batch

build.gradle

~~~
plugins {
  id 'org.springframework.boot' version '2.3.4.RELEASE'
  id 'io.spring.dependency-management' version '1.0.10.RELEASE'
  id 'java'
}

group = 'com.spring'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '1.8'

configurations {
  compileOnly {
    extendsFrom annotationProcessor
  }
}

repositories {
  mavenCentral()
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-batch'
  implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  compileOnly 'org.projectlombok:lombok'
  runtimeOnly 'com.h2database:h2'
  runtimeOnly 'mysql:mysql-connector-java'
  annotationProcessor 'org.projectlombok:lombok'
  testImplementation('org.springframework.boot:spring-boot-starter-test') {
    exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
  }
  testImplementation 'org.springframework.batch:spring-batch-test'
}

test {
  useJUnitPlatform()
}
~~~

<br><br>

## 스프링 배치 테이블

- spring 배치를 위한 테이블 생성

    ~~~sql
    -- Autogenerated: do not edit this file

    CREATE TABLE BATCH_JOB_INSTANCE  (
        JOB_INSTANCE_ID BIGINT  NOT NULL PRIMARY KEY ,
        VERSION BIGINT ,
        JOB_NAME VARCHAR(100) NOT NULL,
        JOB_KEY VARCHAR(32) NOT NULL,
        constraint JOB_INST_UN unique (JOB_NAME, JOB_KEY)
    ) ENGINE=InnoDB;

    CREATE TABLE BATCH_JOB_EXECUTION  (
        JOB_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
        VERSION BIGINT  ,
        JOB_INSTANCE_ID BIGINT NOT NULL,
        CREATE_TIME DATETIME NOT NULL,
        START_TIME DATETIME DEFAULT NULL ,
        END_TIME DATETIME DEFAULT NULL ,
        STATUS VARCHAR(10) ,
        EXIT_CODE VARCHAR(2500) ,
        EXIT_MESSAGE VARCHAR(2500) ,
        LAST_UPDATED DATETIME,
        JOB_CONFIGURATION_LOCATION VARCHAR(2500) NULL,
        constraint JOB_INST_EXEC_FK foreign key (JOB_INSTANCE_ID)
        references BATCH_JOB_INSTANCE(JOB_INSTANCE_ID)
    ) ENGINE=InnoDB;

    CREATE TABLE BATCH_JOB_EXECUTION_PARAMS  (
        JOB_EXECUTION_ID BIGINT NOT NULL ,
        TYPE_CD VARCHAR(6) NOT NULL ,
        KEY_NAME VARCHAR(100) NOT NULL ,
        STRING_VAL VARCHAR(250) ,
        DATE_VAL DATETIME DEFAULT NULL ,
        LONG_VAL BIGINT ,
        DOUBLE_VAL DOUBLE PRECISION ,
        IDENTIFYING CHAR(1) NOT NULL ,
        constraint JOB_EXEC_PARAMS_FK foreign key (JOB_EXECUTION_ID)
        references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
    ) ENGINE=InnoDB;

    CREATE TABLE BATCH_STEP_EXECUTION  (
        STEP_EXECUTION_ID BIGINT  NOT NULL PRIMARY KEY ,
        VERSION BIGINT NOT NULL,
        STEP_NAME VARCHAR(100) NOT NULL,
        JOB_EXECUTION_ID BIGINT NOT NULL,
        START_TIME DATETIME NOT NULL ,
        END_TIME DATETIME DEFAULT NULL ,
        STATUS VARCHAR(10) ,
        COMMIT_COUNT BIGINT ,
        READ_COUNT BIGINT ,
        FILTER_COUNT BIGINT ,
        WRITE_COUNT BIGINT ,
        READ_SKIP_COUNT BIGINT ,
        WRITE_SKIP_COUNT BIGINT ,
        PROCESS_SKIP_COUNT BIGINT ,
        ROLLBACK_COUNT BIGINT ,
        EXIT_CODE VARCHAR(2500) ,
        EXIT_MESSAGE VARCHAR(2500) ,
        LAST_UPDATED DATETIME,
        constraint JOB_EXEC_STEP_FK foreign key (JOB_EXECUTION_ID)
        references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
    ) ENGINE=InnoDB;

    CREATE TABLE BATCH_STEP_EXECUTION_CONTEXT  (
        STEP_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
        SHORT_CONTEXT VARCHAR(2500) NOT NULL,
        SERIALIZED_CONTEXT TEXT ,
        constraint STEP_EXEC_CTX_FK foreign key (STEP_EXECUTION_ID)
        references BATCH_STEP_EXECUTION(STEP_EXECUTION_ID)
    ) ENGINE=InnoDB;

    CREATE TABLE BATCH_JOB_EXECUTION_CONTEXT  (
        JOB_EXECUTION_ID BIGINT NOT NULL PRIMARY KEY,
        SHORT_CONTEXT VARCHAR(2500) NOT NULL,
        SERIALIZED_CONTEXT TEXT ,
        constraint JOB_EXEC_CTX_FK foreign key (JOB_EXECUTION_ID)
        references BATCH_JOB_EXECUTION(JOB_EXECUTION_ID)
    ) ENGINE=InnoDB;

    CREATE TABLE BATCH_STEP_EXECUTION_SEQ (
        ID BIGINT NOT NULL,
        UNIQUE_KEY CHAR(1) NOT NULL,
        constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
    ) ENGINE=InnoDB;

    INSERT INTO BATCH_STEP_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_STEP_EXECUTION_SEQ);

    CREATE TABLE BATCH_JOB_EXECUTION_SEQ (
        ID BIGINT NOT NULL,
        UNIQUE_KEY CHAR(1) NOT NULL,
        constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
    ) ENGINE=InnoDB;

    INSERT INTO BATCH_JOB_EXECUTION_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_EXECUTION_SEQ);

    CREATE TABLE BATCH_JOB_SEQ (
        ID BIGINT NOT NULL,
        UNIQUE_KEY CHAR(1) NOT NULL,
        constraint UNIQUE_KEY_UN unique (UNIQUE_KEY)
    ) ENGINE=InnoDB;

    INSERT INTO BATCH_JOB_SEQ (ID, UNIQUE_KEY) select * from (select 0 as ID, '0' as UNIQUE_KEY) as tmp where not exists(select * from BATCH_JOB_SEQ);
  
    ~~~

- BATCH_JOB_INSTANCE 테이블

    - Job Parameter에 따라 생성되는 테이블이다.

- BATCH_JOB_EXECUTION 테이블

    - JOB_EXECUTION와 JOB_INSTANCE는 부모-자식 관계이다.

    - 자신의 부모 JOB_INSTACNE가 성공/실패했던 모든 내역을 갖고 있다.

    <br><br>

## Spring Batch Job Flow

- BatchStatus

  - Job 또는 Step의 실행 결과를 Spring에 기록할 때 사용 

- ExitStatus

  - Step의 실행 후 상태

<br><br>

## Scope

- @StepScope

  - Tasklet이나 ItemReader, ItemWriter, ItemProcessor에서 사용 가능

  - Step의 실행시점에 해당 컴포넌트를 Spring Bean으로 생성
 
- @JobScope

  - Step 선언문에서 사용 가능

  - Job 실행시점에 Bean이 생성

- Bean 생성 시점을 애플리케이션 실행 시점이 아니라 Job or Step으로 지연 시키면 다음과 같은 장점이 있다.

  - JobParameter의 Late Binding이 가능하다.

  - 동일한 컴포넌트를 병렬 혹은 동시에 사용시 유용

- Job Parameters

  - Scope Bean을 생성할때만 가능

  - Spring Batch는 같은 JobParameter로 같은 Job을 두번 실행하지 않는다.

    - 시스템 변수 사용시 메타 테이블이 전혀 관리되지않는다.

  - Late Binding을 사용할 수 있다.

  - 그렇기에 시스템 변수보다는 JobParameters 사용하는게 유용하다.

<br><br>

## Chunk

Chunk란 데이터 덩어리로 작업 할 때 각 커밋 사이에 처리되는 row 수를 이야기한다.

즉, Chunk 지향 처리란 한 번에 하나씩 데이터를 읽어 Chunk라는 덩어리를 만든 뒤, Chunk 단위로 트랜잭션을 다루는 것을 의미한다.

- Page Size VS Chunk Size

  - 2개의 값이 의미하는 바가 다르지만 보편적으로 2개의 값을 일치시키는 것이 성능적으로 좋다.

  - Page Size : 한번에 조회할 Item의 양

  - Chunk Size : 한번에 처리될 트랜잭션 단위
